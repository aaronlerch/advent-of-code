#!/usr/bin/env ruby

require 'curses'

FLASH_THRESHOLD=10
STEPS=4

LOG_LEVEL_DEBUG=3
LOG_LEVEL_INFO=2
LOG_LEVEL_WARN=1
LOG_LEVEL_ERROR=0

LOG_LEVEL=LOG_LEVEL_INFO

PAUSE_ON_ALL=true

COLOR_WHITE=255 # no color: "\033[0m"
COLOR_GREEN=46 # "\033[0;32m"
COLOR_HIGHLIGHT=200

begin
    Curses.noecho
    Curses.init_screen
    Curses.crmode
    Curses.start_color

    @map = []

    input = File.readlines("example.txt").map(&:chomp)
    input.each { |line| @map << line.chars.map(&:to_i) }

    @flash_count = 0
    @current_step = 0
    @step_desc = ""
    @highlight_pos = nil

    def do_pause(intermediate=false)
        if PAUSE_ON_ALL || !intermediate
            print_map
            Curses.getch
            # sleep 0.5
        end
    end

    def substep(msg=nil)
        @step_desc = msg
    end

    def log(msg=nil,level=LOG_LEVEL_DEBUG)
        #$stderr.write "#{msg}\r\n" if level <= LOG_LEVEL
    end

    def log_point(map, x, y, msg=nil)
        #$stderr.write "[#{x},#{y}] VALUE #{map[x][y]} #{msg}\r\n"
    end

    def do_for_all(map)
        (0...map.length).each do |x|
            (0...map[x].length).each do |y|
                yield(map, x, y)
            end
        end
    end

    def get_flashes
        flashes = []
        do_for_all(@map) do |m,x,y|
            flashes << [x,y] if m[x][y] == FLASH_THRESHOLD
        end
        flashes
    end

    def increment_all
        log "=== BEGIN INCREMENTING ALL ==="
        do_for_all(@map) do |m,x,y|
            increment(m,x,y)
        end
        log "=== END INCREMENTING ALL ==="
    end

    def reset_energies
        log "=== BEGIN RESET ENERGY ==="
        do_for_all(@map) do |m,x,y|
            value = m[x][y]
            m[x][y] = 0 if value >= FLASH_THRESHOLD
        end
        log "=== END RESET ENERGY ==="
    end

    def increment(map,x,y)
        log_point(map,x,y)
        prev = @highlight_pos
        @highlight_pos = [x,y]
        value = map[x][y]
        value += 1
        map[x][y] = value
        log_point(map,x,y)
        @highlight_pos = prev
        
        # if we specifically crossed into FLASH_THRESHOLD, record it
        if value == FLASH_THRESHOLD
            @flash_count += 1
            log_point(map, x, y, "FLASH")
        end
    end

    def eval_flash(map, x, y)
        value = map[x][y]
        
        # ignore if we aren't flashing
        return if value != FLASH_THRESHOLD

        substep "evaluting adjacent cells to [#{x},#{y}]"
        prev = @highlight_pos
        @highlight_pos = [x,y]
        # we specifically flashed before this eval
        # trigger adjacent locations
        # up left, up, up right
        if x > 0 && y > 0
            increment(map, x-1, y-1)
            eval_flash(map, x-1, y-1)
            do_pause(true)
        end
        if x > 0
            increment(map, x-1, y)
            eval_flash(map, x-1, y)
            do_pause(true)
        end
        if x > 0 && map[x-1][y+1]
            increment(map, x-1, y+1)
            eval_flash(map, x-1, y+1)
            do_pause(true)
        end
        # left, right
        if y > 0
            increment(map, x, y-1)
            eval_flash(map, x, y-1)
            do_pause(true)
        end
        if map[x][y+1]
            increment(map, x, y+1)
            eval_flash(map, x, y+1)
            do_pause(true)
        end
        # down left, down, down right
        if y > 0 && map[x+1]
            increment(map, x+1, y-1)
            eval_flash(map, x+1, y-1)
            do_pause(true)
        end
        if map[x+1]
            increment(map, x+1, y)
            eval_flash(map, x+1, y)
            do_pause(true)
        end
        if map[x+1] && map[x+1][y+1]
            increment(map, x+1, y+1)
            eval_flash(map, x+1, y+1)
            do_pause(true)
        end
        substep "done evaluting adjacent cells to [#{x},#{y}]"
        @highlight_pos = prev
    end

    def eval_flashes
        # evaluating the entire map, which will dynamically change during evaluation,
        # means we need to first capture the locations of flashes at this point in time.
        # We want to use the current state of flashed octopii as an initiator,
        # even as it triggers recursive behavior

        flashes = get_flashes
        substep "initializing with #{flashes.length} flashes"
        flashes.each do |f|
            x,y = f
            eval_flash @map, x, y
        end
        substep "finished evaluating flashes"
    end

    def start_green
        Curses.init_pair(COLOR_GREEN, COLOR_GREEN, 0)
        Curses.attrset(Curses.color_pair(COLOR_GREEN))
    end

    def start_white
        Curses.init_pair(COLOR_WHITE, COLOR_WHITE, 0)
        Curses.attrset(Curses.color_pair(COLOR_WHITE))
    end

    def start_highlight
        Curses.init_pair(COLOR_HIGHLIGHT, COLOR_HIGHLIGHT, 0)
        Curses.attrset(Curses.color_pair(COLOR_HIGHLIGHT))
    end

    def print_map
        line = 0
        Curses.refresh
        Curses.setpos(line, 0)
        line += 1
        Curses.addstr ">>> STEP #{@current_step}"
        Curses.setpos(line, 0)
        line += 1
        Curses.addstr ">>> SUB-STEP: #{@step_desc}"

        (0...@map.length).each do |x|
            Curses.setpos(line, 0)
            line += 1
            (0...@map[x].length).each do |y|
                value = @map[x][y]
                if value >= FLASH_THRESHOLD
                    start_green
                    value = "*"
                end
                start_highlight if @highlight_pos == [x,y]
                Curses.addstr value.to_s
                start_white # reset back to white
            end
        end
    
        line += 1
        Curses.setpos(line, 0)
        line += 1
        Curses.addstr "Flashes: #{@flash_count}"
    end 

    def step
        # increase energy level of all octopii
        substep "incrementing all"
        increment_all
        substep "evaluating flashes"
        eval_flashes
        substep "resetting energies"
        reset_energies
    end

    substep "initial state"
    print_map
    do_pause

    (1..STEPS).each do |i|
        @current_step += 1
        step
        print_map
        do_pause
    end

    log "\r\nFlashes: #{@flash_count}", LOG_LEVEL_INFO

    Curses.getch

ensure
    Curses.close_screen
end
