#!/usr/bin/env ruby

require_relative './node'

INPUT_FILE = "example.txt"
input = File.readlines(INPUT_FILE).map(&:chomp)

grid = []
input.each { |line| grid << line.chars.map(&:to_i) }

@max_y = grid.length - 1
@max_x = grid.first.length - 1

# Create one node per location (to reuse objects)
nodes = {}
(0..@max_y).each do |y|
    (0..@max_x).each do |x|
        nodes[[y,x]] = Node.new(y, x, grid[y][x])
    end
end

# turn the grid into a tree of nodes
def attach_neighbors(node, nodes)
    # ignore if we've already connected this node
    return if connected_nodes.include? node

    # capture this node as already connected
    connected_nodes << node

    # build the nodes from this node's location
    x, y = node.x, node.y

    # try right, down, left, up
    neighbors = [nodes[[y,x+1]], nodes[[y+1,x]], nodes[[y,x-1]], nodes[[y-1,x]]].compact.sort_by { |n| n.value }

    # add the neighbors
    neighbors.each { |c| node.add_neighbor(c) }

    # connect each neighbor to their nodes
    neighbors.each { |c| connect_neighbor_nodes(c, connected_nodes, nodes) }
end

(0..@max_y).each do |y|
    (0..@max_x).each do |x|
        # For each node, attach it's neighbors
        attach_neighbors(nodes[[y,x]], nodes)
    end
end

start_node = nodes[0][0]
goal_node = nodes[@max_y][@max_x]
connect_neighbor_nodes(start_node, connected_nodes, nodes)

puts "Connected nodes: #{connected_nodes.length}"

# Starting with each child of the start_node,
# compute the length until the end node is reached, OR
# until our current sum of values is > the known lowest path

# @lowest_path = nil

# def visit(node, risk, visited)
#     return if visited.include? node

#     # puts "Visiting #{node}"
#     # we are visiting this node
#     visited << node

#     risk += node.value
#     # exit here if we are cutting off this branch
#     if @lowest_path && risk > @lowest_path
#         visited.pop
#         return
#     end

#     if node.finish?
#         @lowest_path = risk if @lowest_path.nil? || @lowest_path > risk
#         puts "END: risk=#{risk}, lowest_path=#{@lowest_path}"
#         visited.pop
#         return
#     end

#     node.children.each do |child|
#         visit(child, risk, visited)
#     end

#     # pop ourselves from the visit tracking before returning
#     visited.pop
# end

# start_node.children.each do |node|
#     visit(node, 0, [start_node])
# end

#puts "Lowest risk path is: #{@lowest_path || 'NONE'}"


# Implement an A* search algorithm

def reconstruct_path(came_from, current)
    total_path = [current]
    while came_from.keys.include? current
        current = came_from[current]
        total_path.prepend current
    end
    return total_path
end

def a_star(start, goal, h)
    open_set = [start]
    came_from = {}
    g_score = Hash.new(Float::INFINITY)
    g_score[start] = 0
    f_score = Hash.new(Float::INFINITY)
    f_score[start] = h.call(start)

    while !open_set.empty?
        current = open_set.first # assumes sorted by cost (node.value for us)
        if current == goal
            return reconstruct_path(came_from, current)
        end

        open_set.delete current

        current.children.each do |child|
            tentative_g_score = g_score[current] + child.value
            if tentative_g_score < g_score[child]
                came_from[child] = current
                g_score[child] = tentative_g_score
                f_score[child] = tentative_g_score + h.call(child)
                unless open_set.include? child
                    open_set << child
                end
            end
        end

        open_set.sort_by! { |n| n.value }
    end
end

path = a_star(start_node, goal_node, -> (node) { node.value })

result = path.sum { |n| n.value } - start_node.value

puts "Risk of best path: #{result}"

puts path